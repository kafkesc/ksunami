use std::collections::HashMap;
use std::fs::File;
use std::io::{Error, Read};
use std::path::PathBuf;

use rand::distributions::{Alphanumeric, DistString};
use rand::{thread_rng, Rng};
use rdkafka::message::{Header, OwnedHeaders};
use rdkafka::producer::FutureRecord;

/// Helps to generate a possible value used in [`RecordGenerator`].
///
/// Specifically, this is used for the [`RecordGenerator::key_field`] and [`RecordGenerator::payload_field`],
/// to specify what content should be generated for those fields when a Kafka record is generated
/// (via [`RecordGenerator::generate_record`]).
#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub enum ValueGenerator {
    /// A user provided string.
    String(String),

    /// The content of a file.
    File(PathBuf),

    /// A random alphanumeric string.
    RandAlphaNum(usize),

    /// A random bytes array.
    RandBytes(usize),

    /// A random (signed) integer.
    RandInt(i64, i64),

    /// A random float.
    RandFloat(f64, f64),
}

impl ValueGenerator {
    /// Generates a `Vec<u8>` of bytes containing the value created by this generator, or an error.
    fn generate(&self) -> Result<Vec<u8>, Error> {
        match self {
            ValueGenerator::String(s) => Ok(s.as_bytes().to_vec()),
            ValueGenerator::File(bp) => {
                debug!("Loading content of file {:?}", bp);
                let mut f = File::open(bp)?;
                let mut buf = Vec::new();
                f.read_to_end(&mut buf)?;

                Ok(buf)
            }
            ValueGenerator::RandAlphaNum(l) => {
                let rand_alpha = Alphanumeric.sample_string(&mut thread_rng(), *l);

                Ok(rand_alpha.as_bytes().to_vec())
            }
            ValueGenerator::RandBytes(l) => {
                let random_bytes: Vec<u8> = (0..*l).map(|_| thread_rng().gen::<u8>()).collect();

                Ok(random_bytes)
            }
            ValueGenerator::RandInt(min, max) => {
                let random_int = thread_rng().gen_range(*min..=*max);

                Ok(random_int.to_be_bytes().to_vec())
            }
            ValueGenerator::RandFloat(min, max) => {
                let random_float = thread_rng().gen_range(*min..=*max);

                Ok(random_float.to_be_bytes().to_vec())
            }
        }
    }

    /// Implementation of [`clap::value_parser`], used to create an argument by parsing a user-provided value.
    ///
    /// The `&str` provided must be of one of the following formats:
    ///
    /// * `string:STR`: `STR` is parsed to `String` and will be the generated value
    /// * `file:PATH`: `PATH` is parsed to `PathBuf` to an existing file, failing if it can't read it's content
    /// * `alpha:LENGTH`: `LENGTH` is parsed to `usize` length of a randomly generated alphanumeric string
    /// * `bytes:LENGTH`: `LENGTH` is parsed to `usize` length of a randomly generated bytes array
    /// * `int:MIN-MAX`: `MIN` and `MAX` are parsed to `i64`s of an inclusive range from which to pick a random `i64`
    /// * `float:MIN-MAX`: `MIN` and `MAX` are parsed to `f64`s of an inclusive range from which to pick a random `f64`
    ///
    /// In case of error, it returns a `String` that [`clap`] adds to the error message returned to the user.
    ///
    pub fn clap_parser(val_gen_as_str: &str) -> Result<ValueGenerator, String> {
        let (val_gen_type, val_gen_input) = match val_gen_as_str.split_once(':') {
            None => {
                return Err("Should have 'TYPE:INPUT' format".to_string());
            }
            Some((t, c)) => (t, c),
        };

        match val_gen_type {
            "string" => Ok(ValueGenerator::String(val_gen_input.to_string())),
            "file" => {
                let path = PathBuf::from(val_gen_input);

                if !path.exists() || !path.is_file() {
                    Err(format!("INPUT file '{}' does not exist or is not a file", path.display()))
                } else {
                    Ok(ValueGenerator::File(path))
                }
            }
            "alpha" => {
                let res = val_gen_input.parse::<usize>();

                match res {
                    Err(e) => Err(format!("Failed to parse INPUT 'SIZE' from 'alpha:SIZE': {e}")),
                    Ok(size) => Ok(ValueGenerator::RandAlphaNum(size)),
                }
            }
            "bytes" => {
                let res = val_gen_input.parse::<usize>();

                match res {
                    Err(e) => Err(format!("Failed to parse INPUT 'SIZE' from 'bytes:SIZE': {e}")),
                    Ok(size) => Ok(ValueGenerator::RandBytes(size)),
                }
            }
            "int" => match val_gen_input.split_once('-') {
                None => Err("Inclusive range should have 'min-max' format".to_string()),
                Some((min_str, max_str)) => {
                    let min = match min_str.parse::<i64>() {
                        Err(e) => return Err(format!("Failed to parse INPUT 'MIN' from 'int:MIN-MAX': {e}")),
                        Ok(v) => v,
                    };

                    let max = match max_str.parse::<i64>() {
                        Err(e) => return Err(format!("Failed to parse INPUT 'MAX' from 'int:MIN-MAX': {e}")),
                        Ok(v) => v,
                    };

                    Ok(ValueGenerator::RandInt(min, max))
                }
            },
            "float" => match val_gen_input.split_once('-') {
                None => Err("Inclusive range should have 'min-max' format".to_string()),
                Some((min_str, max_str)) => {
                    let min = match min_str.parse::<f64>() {
                        Err(e) => return Err(format!("Failed to parse INPUT 'MIN' from 'float:MIN-MAX': {e}")),
                        Ok(v) => v,
                    };

                    let max = match max_str.parse::<f64>() {
                        Err(e) => return Err(format!("Failed to parse INPUT 'MAX' from 'float:MIN-MAX': {e}")),
                        Ok(v) => v,
                    };

                    Ok(ValueGenerator::RandFloat(min, max))
                }
            },
            _ => Err(format!("Unsupported TYPE '{val_gen_type}:...'")),
        }
    }
}

/// The data of a Kafka Record, as generated by [`RecordGenerator`].
///
/// The `key` and `payload` value are `Vec<u8>`,
/// as this is the most basic form of data we can give to the Kafka Producer.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct GeneratedRecord {
    pub topic: String,
    pub key: Option<Vec<u8>>,
    pub payload: Option<Vec<u8>>,
    pub partition: Option<i32>,
    pub headers: HashMap<String, String>,
}

impl GeneratedRecord {
    /// Converts the `GeneratedRecord` into a [`rdkafka::producer::FutureRecord`], usable with [`rdkafka::producer::FutureProducer`].
    pub fn as_future_record(&self) -> FutureRecord<Vec<u8>, Vec<u8>> {
        let mut rec: FutureRecord<Vec<u8>, Vec<u8>> = FutureRecord::to(self.topic.as_str());

        // Set record key (if available)
        rec.key = if let Some(k) = &self.key {
            Some(k)
        } else {
            None
        };

        // Set record payload (if available)
        rec.payload = if let Some(p) = &self.payload {
            Some(p)
        } else {
            None
        };

        // Set partition
        rec.partition = self.partition;

        // Set headers
        let mut rec_headers = OwnedHeaders::new();
        for (k, v) in &self.headers {
            rec_headers = rec_headers.insert(Header {
                key: k,
                value: Some(v),
            });
        }
        rec.headers = Some(rec_headers);
        rec
    }
}

/// Utility to generate records.
#[derive(Debug, Clone, PartialEq)]
pub struct RecordGenerator {
    /// Topic the record is destined to.
    destination_topic: String,

    /// Generators of the content that will go in the record key.
    key_generator: Option<ValueGenerator>,

    /// Offers memoization for the record `key_generator`, depending on the [`ValueGenerator`] used.
    /// This is used when the value that goes in the key doesn't change at every record generation.
    key_generated_content: Option<Vec<u8>>,

    /// Generators of the content that will go in the record payload.
    payload_generator: Option<ValueGenerator>,

    /// Offers memoization for the record `payload_generator`, depending on the [`ValueGenerator`] used.
    /// This is used when the value that goes in the payload doesn't change at every record generation.
    payload_generated_content: Option<Vec<u8>>,

    /// Headers that will be added to the record.
    headers: HashMap<String, String>,

    /// Topic partition the record is destined to.
    /// If absent, this will be left to the Kafka Producer partitioner to determine.
    destination_partition: Option<i32>,
}

impl RecordGenerator {
    pub fn new(destination_topic: String) -> RecordGenerator {
        RecordGenerator {
            destination_topic,
            key_generator: None,
            key_generated_content: None,
            payload_generator: None,
            payload_generated_content: None,
            headers: HashMap::new(),
            destination_partition: None,
        }
    }

    pub fn add_record_header(&mut self, k: String, v: String) {
        self.headers.insert(k, v);
    }

    pub fn set_key_generator(&mut self, key_generator: ValueGenerator) -> Result<(), Error> {
        // Memoize content, if appropriate
        self.key_generated_content = match key_generator {
            ValueGenerator::String(_) | ValueGenerator::File(_) => Some(key_generator.generate()?),
            _ => None,
        };

        self.key_generator = Some(key_generator);

        Ok(())
    }

    pub fn set_payload_generator(&mut self, payload_generator: ValueGenerator) -> Result<(), Error> {
        // Memoize content, if appropriate
        self.payload_generated_content = match payload_generator {
            ValueGenerator::String(_) | ValueGenerator::File(_) => Some(payload_generator.generate()?),
            _ => None,
        };

        self.payload_generator = Some(payload_generator);

        Ok(())
    }

    pub fn set_destination_partition(&mut self, partition: i32) {
        self.destination_partition = Some(partition);
    }

    pub fn generate_record(&self) -> Result<GeneratedRecord, Error> {
        let rec = GeneratedRecord {
            topic: self.destination_topic.clone(),
            key: if let Some(k_mem) = &self.key_generated_content {
                Some(k_mem.to_vec())
            } else if let Some(k) = &self.key_generator {
                Some(k.generate()?)
            } else {
                None
            },
            payload: if let Some(p_mem) = &self.payload_generated_content {
                Some(p_mem.to_vec())
            } else if let Some(p) = &self.payload_generator {
                Some(p.generate()?)
            } else {
                None
            },
            partition: self.destination_partition,
            headers: self.headers.clone(),
        };

        Ok(rec)
    }
}

#[cfg(test)]
mod tests {
    use rdkafka::message::Headers;

    use super::*;

    #[test]
    fn test_payload_only() {
        let mut generator = RecordGenerator::new("a_topic_name".to_string());
        assert!(generator.set_payload_generator(ValueGenerator::String("a payload content".to_string())).is_ok());

        let rec = generator.generate_record().unwrap();
        assert_eq!("a_topic_name", rec.topic);
        assert_eq!(None, rec.key);
        assert_eq!("a payload content".as_bytes(), rec.payload.clone().unwrap());
        assert!(rec.headers.is_empty());
        assert_eq!(None, rec.partition);

        let fut_rec = rec.as_future_record();
        assert_eq!("a_topic_name", fut_rec.topic);
        assert!(fut_rec.key.is_none());
        assert!(fut_rec.payload.is_some());
        assert!(fut_rec.partition.is_none());
        assert!(fut_rec.headers.is_some());
        assert_eq!(0, fut_rec.headers.unwrap().count());

        generator.set_destination_partition(10);
        let rec = generator.generate_record().unwrap();
        assert_eq!(Some(10), rec.partition);

        let fut_rec = rec.as_future_record();
        assert_eq!(Some(10), fut_rec.partition);
    }

    #[test]
    fn test_key_and_headers() {
        let mut generator = RecordGenerator::new("another_topic".to_string());
        assert!(generator.set_payload_generator(ValueGenerator::String("another payload".to_string())).is_ok());

        generator.add_record_header("k1".to_string(), "v1".to_string());
        generator.add_record_header("k2".to_string(), "v2".to_string());
        generator.add_record_header("k3".to_string(), "v3".to_string());

        assert!(generator.set_key_generator(ValueGenerator::RandInt(10, 10)).is_ok());

        let rec = generator.generate_record().unwrap();
        assert_eq!("another_topic", rec.topic);
        assert_eq!(10u64.to_be_bytes().to_vec(), rec.key.clone().unwrap());
        assert_eq!("another payload".as_bytes(), rec.payload.clone().unwrap());

        assert_eq!(3, rec.headers.len());
        assert!(rec.headers.contains_key("k1"));
        assert!(rec.headers.contains_key("k2"));
        assert!(rec.headers.contains_key("k3"));

        assert_eq!(None, rec.partition);

        let fut_rec = rec.as_future_record();
        assert_eq!("another_topic", fut_rec.topic);
        assert!(fut_rec.key.is_some());
        assert!(fut_rec.payload.is_some());
        assert!(fut_rec.partition.is_none());
        assert!(fut_rec.headers.is_some());
        assert_eq!(3, fut_rec.headers.unwrap().count());
    }

    #[test]
    fn test_file_payload() {
        let cargo_toml_path = PathBuf::from("./Cargo.toml");
        let mut generator = RecordGenerator::new("topic_zzz".to_string());
        assert!(generator.set_payload_generator(ValueGenerator::File(cargo_toml_path.clone())).is_ok());

        let rec = generator.generate_record().unwrap();
        assert_eq!("topic_zzz", rec.topic);
        assert_eq!(None, rec.key);
        let mut f = File::open(cargo_toml_path).unwrap();
        let mut cargo_toml_content = Vec::new();
        f.read_to_end(&mut cargo_toml_content).unwrap();

        assert_eq!(cargo_toml_content, rec.payload.unwrap());
        assert!(rec.headers.is_empty());
        assert_eq!(None, rec.partition);
    }

    #[test]
    fn test_randomizers() {
        let mut generator = RecordGenerator::new("topic".to_string());
        assert!(generator.set_key_generator(ValueGenerator::RandBytes(20)).is_ok());
        assert!(generator.set_payload_generator(ValueGenerator::RandAlphaNum(20)).is_ok());

        let rec = generator.generate_record().unwrap();
        assert_eq!(20, rec.key.unwrap().len());
        assert!(std::str::from_utf8(rec.payload.unwrap().as_slice()).is_ok());

        assert!(generator.set_payload_generator(ValueGenerator::RandInt(123, 125)).is_ok());
        assert!(generator.set_key_generator(ValueGenerator::RandFloat(1.5, 2.0)).is_ok());

        let rec = generator.generate_record().unwrap();
        let rec_key = f64::from_be_bytes(rec.key.unwrap().as_slice().try_into().unwrap());
        assert!((1.5..=2.0).contains(&rec_key));

        let rec_payload = i64::from_be_bytes(rec.payload.unwrap().as_slice().try_into().unwrap());
        assert!((123..=125).contains(&rec_payload));
    }

    #[test]
    fn test_value_generator_clap_parser() {
        let res = ValueGenerator::clap_parser("string:StRiNgA");
        assert!(res.is_ok());
        assert_eq!(ValueGenerator::String("StRiNgA".to_string()), res.unwrap());

        let res = ValueGenerator::clap_parser("file:Cargo.toml");
        assert!(res.is_ok());
        assert_eq!(ValueGenerator::File(PathBuf::from("Cargo.toml")), res.unwrap());

        let res = ValueGenerator::clap_parser("alpha:11");
        assert!(res.is_ok());
        assert_eq!(ValueGenerator::RandAlphaNum(11), res.unwrap());

        let res = ValueGenerator::clap_parser("bytes:21");
        assert!(res.is_ok());
        assert_eq!(ValueGenerator::RandBytes(21), res.unwrap());

        let res = ValueGenerator::clap_parser("int:10-100");
        assert!(res.is_ok());
        assert_eq!(ValueGenerator::RandInt(10, 100), res.unwrap());

        let res = ValueGenerator::clap_parser("float:11-213.1");
        assert!(res.is_ok());
        assert_eq!(ValueGenerator::RandFloat(11., 213.1), res.unwrap());
    }

    #[test]
    fn test_failure_value_generator_clap_parser() {
        let res = ValueGenerator::clap_parser("stringz:StRiNgA");
        assert!(res.is_err());
        assert_eq!("Unsupported TYPE 'stringz:...'", res.unwrap_err());

        let res = ValueGenerator::clap_parser("asdasd");
        assert!(res.is_err());
        assert_eq!("Should have 'TYPE:INPUT' format", res.unwrap_err());

        let res = ValueGenerator::clap_parser("file:does_not_exist");
        assert!(res.is_err());
        assert_eq!("INPUT file 'does_not_exist' does not exist or is not a file", res.unwrap_err());

        let res = ValueGenerator::clap_parser("bytes:gimme_some");
        assert!(res.is_err());
        assert_eq!("Failed to parse INPUT 'SIZE' from 'bytes:SIZE': invalid digit found in string", res.unwrap_err());

        let res = ValueGenerator::clap_parser("float:123,456");
        assert!(res.is_err());
        assert_eq!("Inclusive range should have 'min-max' format", res.unwrap_err());

        let res = ValueGenerator::clap_parser("int:abc-asd");
        assert!(res.is_err());
        assert_eq!("Failed to parse INPUT 'MIN' from 'int:MIN-MAX': invalid digit found in string", res.unwrap_err());
    }
}
